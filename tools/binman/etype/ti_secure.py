# SPDX-License-Identifier: GPL-2.0+
# Copyright (c) 2022 Texas Instruments Incorporated - https://www.ti.com/
#

# Support for signed binaries for TI K3 platform

from collections import OrderedDict
import os

from binman.entry import Entry, EntryArg

from dtoc import fdt_util
from patman import tools

class Entry_ti_secure(Entry):
    """An entry which contains a signed x509 binary for signing TI
    General Purpose as well as High-Security devices.

    Properties / Entry arguments:
	- filename: filename of binary file to be secured

    Output files:
        - filename_x509 - output file generated by secure x509 signing script (which
            used as entry contents)
    """
    def __init__(self, section, etype, node):
        super().__init__(section, etype, node)
        self.filename = fdt_util.GetString(self._node, 'filename')
        self.key = fdt_util.GetString(self._node, 'key', "")
        self.core = fdt_util.GetInt(self._node, 'core', 16)
        self.load_addr = fdt_util.GetInt(self._node, 'load', 0x41c00000)
        self.sw_rev = fdt_util.GetInt(self._node, 'sw-rev')
        self.cert3 = fdt_util.GetBool(self._node, 'sysfw-cert', False)
        self.secure = fdt_util.GetBool(self._node, 'secure', False)
        self.toolpresent = False
        if not self.filename:
            self.Raise("ti_secure must have a 'filename' property")
        self.toolspath, = self.GetEntryArgsOrProps(
            [EntryArg('ti-secure-dev-pkg-path', str)])
        if not self.toolspath:
            print("WARNING: TI_SECURE_DEV_PKG environment " \
                "variable must be defined for TI GP and HS devices! " +
                self.filename + " was NOT signed!")
            return

        if self.cert3 == True:
            self.tool = self.toolspath + "/scripts/gen_x509_cert3.sh"
            self.core = "m3"
        elif self.secure == True:
            self.tool = self.toolspath + "/scripts/secure-binary-image.sh"
        else:
            self.tool = self.toolspath + "/scripts/gen_x509_cert.sh"
        self.toolpresent = os.path.exists(self.tool)
        if not self.toolpresent:
            print(self.tool + " not found. " +
                self.filename + " was NOT signed! ")

        if self.key == "" and not self.secure:
            self.key = self.toolspath + "/keys/ti-degenerate-key.pem"
            self.keypresent = os.path.exists(self.key)
            if not self.keypresent:
                print(self.key + " not found. " +
                    self.filename + " was NOT signed! ")
            else:
                print("Signing " + self.filename + " with degenerate RSA key...")
        else:
            self.key = self.toolspath + self.key
            print("Signing " + self.filename + " with " + self.key)

        if self.sw_rev is None and not self.secure:
            self.sw_revfile = self.toolspath + "/keys/swrv.txt"
            with open(self.sw_revfile) as f:
                self.sw_rev = int(f.read())
            self.swrevpresent = os.path.exists(self.sw_rev)
            if not self.swrevpresent:
                print(self.sw_rev + " not found. " +
                    "Software revision file not found. Default may not work on HS hardware.")
                self.sw_rev = 1

    def ObtainContents(self):
        input_fname = self.filename
        output_fname = input_fname + "_x509"
        if self.secure:
            args = [
                input_fname, output_fname,
            ]
        else:
            args = [
                '-c', str(self.core),
                '-b', input_fname,
                '-o', output_fname,
                '-l', hex(self.load_addr),
                '-r', str(self.sw_rev),
                '-k', self.key,
            ]
            if self.cert3 == True:
                args.insert(0, '-d')
        if self.toolpresent:
            stdout = tools.run(self.tool, *args)
        else:
            stdout = tools.run('cp', *args)
            print(output_fname + ' not signed!')

        self.SetContents(tools.read_file(output_fname))
        return True
